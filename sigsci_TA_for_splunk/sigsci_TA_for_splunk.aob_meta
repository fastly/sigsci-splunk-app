{"basic_builder": {"appname": "sigsci_TA_for_splunk", "friendly_name": "Signal Sciences WAF TA", "version": "1.0.28", "author": "Fastly", "description": "For users of Fastly who would like to enrich their Splunk data with information from Fastly. This app with simple configuration enabled the importing of Events, Activity, and raw request information to Splunk.\n\nThis is an open source project, no support provided, public repository is available and installation documentation can be found at https://github.com/fastly/sigsci-splunk-app. The best way to report issues with the app is to create an Issue on the github page so that it can be tracked.", "theme": "#f07a35", "large_icon": "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", "small_icon": "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", "visible": true, "tab_version": "4.1.1", "tab_build_no": "0", "build_no": 5}, "data_input_builder": {"datainputs": [{"index": "default", "sourcetype": "sigsci-event", "interval": "300", "use_external_validation": true, "streaming_mode_xml": true, "name": "SigsciEvent", "title": "SigsciEvent", "description": "", "type": "customized", "parameters": [{"name": "site_api_name", "label": "Site API Name", "help_string": "This is the Site API Name. It should not be a URL.", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "splunk-demo-server"}, {"name": "time_delta", "label": "Time Delta in seconds", "help_string": "This is the time period that the Moduler Input will pull data. It should be the exact same as the Modular Input interval.", "required": true, "format_type": "text", "default_value": "300", "placeholder": "300", "type": "text", "value": "300"}], "data_inputs_options": [{"type": "customized_var", "name": "site_api_name", "title": "Site API Name", "description": "This is the Site API Name. It should not be a URL.", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "time_delta", "title": "Time Delta in seconds", "description": "This is the time period that the Moduler Input will pull data. It should be the exact same as the Modular Input interval.", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "300", "placeholder": "300"}], "code": "# encoding = utf-8\n\nimport time\nfrom datetime import datetime, timedelta\nfrom timeit import default_timer as timer\nimport requests\nimport calendar\nimport json\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n\n\n# def use_single_instance_mode():\n#     return True\n\n\ndef validate_input(helper, definition):\n    # This example accesses the modular input variable\n    site_name = definition.parameters.get('site_api_name', None)\n    if site_name is None or site_name == \"\":\n        msg = \"The site_name can not be empty\"\n        raise ValueError(\n            \"InvalidSiteName\",\n            msg\n        )\n    elif \"http\" in site_name:\n        msg = (\n            \"The site name is not the full URL it should be the \",\n            \"API Name of the site like 'my_example_site'\"\n        )\n        raise ValueError(\n            \"InvalidSiteName\",\n            msg\n        )\n    elif \" \" in site_name:\n        msg = (\n            \"The site name should be the API Name of the site like \",\n            \"not the Display Name. Example would be 'my_site_name' instead of \",\n            \"My Site Name\"\n        )\n        raise ValueError(\n            \"InvalidSiteName\",\n            msg\n        )\n    time_delta = definition.parameters.get('time_delta', None)\n    if time_delta is None or time_delta == \"\":\n        msg = \"The frequency can not be empty\"\n        raise ValueError(\n            \"InvalidFrequency\",\n            msg\n        )\n    else:\n        try:\n            int(time_delta)\n        except Exception as error:\n            msg = \"Time delta must be an integer\"\n            raise ValueError(\n                \"InvalidFrequency\",\n                msg\n            )\n    pass\n\n\ndef collect_events(helper, ew):\n    start = timer()\n    # loglevel = helper.get_log_level()\n    # Proxy setting configuration\n    # proxy_settings = helper.get_proxy()\n    global_email = helper.get_global_setting(\"email\")\n    global_api_token = helper.get_global_setting(\"api_token\")\n    global_corp_api_name = helper.get_global_setting(\"corp_api_name\")\n    api_host = 'https://dashboard.signalsciences.net'\n    helper.log_info(\"email: %s\" % global_email)\n    helper.log_info(\"corp: %s\" % global_corp_api_name)\n    python_requests_version = requests.__version__\n    user_agent_version = \"1.0.26\"\n    user_agent_string = (\n        f\"TA-sigsci-waf/{user_agent_version} \"\n        f\"(PythonRequests {python_requests_version})\"\n    )\n\n    def check_response(code, response_text, current_site=None,\n                       from_time=None, until_time=None):\n        success = False\n        site_name = current_site\n        base_msg = {\n            \"from\": from_time,\n            \"until\": until_time,\n            \"global_email\": global_email,\n            \"global_corp_api_name\": global_corp_api_name,\n            \"site_name\": site_name,\n            \"response_text\": response_text,\n            \"status_code\": code,\n        }\n        if code == 400:\n            if \"Rate limit exceeded\" in response_text:\n                base_msg[\"msg\"] = \"rate-limit\"\n            else:\n                base_msg[\"error\"] = \"BAD API Request\"\n                base_msg[\"msg\"] = \"bad-request\"\n        elif code == 500:\n            base_msg[\"error\"] = \"Internal Server Error\"\n            base_msg[\"msg\"] = \"internal-error\"\n        elif code == 401:\n            base_msg[\"error\"] = \"Unauthorized. Incorrect credentials or lack \" \\\n                                \"of permissions\"\n            base_msg[\"msg\"] = \"unauthorized\"\n        elif 400 <= code <= 599 and code != 400 and code != 500 and code != 401:\n            base_msg[\"error\"] = \"Unknown Error\"\n            base_msg[\"msg\"] = \"other-error\"\n        else:\n            success = True\n        return success, base_msg\n\n    def get_request_data(url, headers):\n        method = \"GET\"\n        response_raw = helper.send_http_request(\n            url,\n            method,\n            parameters=None,\n            payload=None,\n            headers=headers,\n            cookies=None,\n            verify=True,\n            cert=None,\n            timeout=None,\n            use_proxy=True\n        )\n        response_codee = response_raw.status_code\n        response_error = response_raw.text\n        return response_raw, response_codee, response_error\n\n    def pull_events(current_site, delta, key=None):\n        site_name = current_site\n        until_time = datetime.utcnow()\n        until_time = until_time.replace(second=0, microsecond=0)\n        from_time = until_time - timedelta(seconds=delta)\n        until_time = calendar.timegm(until_time.utctimetuple())\n        from_time = calendar.timegm(from_time.utctimetuple())\n        from_time_friendly = datetime.fromtimestamp(from_time)\n        until_time_friendly = datetime.fromtimestamp(until_time)\n        helper.log_info(\"SiteName: %s\" % site_name)\n\n        helper.log_info(f\"Start Period: {from_time_friendly}\")\n        helper.log_info(f\"End Period: {until_time_friendly}\")\n\n\n        input_name = helper.get_input_stanza_names()\n        single_name = \"\"\n\n        if type(input_name) is dict and input_name > 1:\n            helper.log_info(\"Multi instance mode\")\n            for current_name in input_name:\n                single_name = current_name\n        else:\n            helper.log_info(\"Single instance mode\")\n            helper.log_info(\"Inputs: %s\" % input_name)\n            helper.log_info(\"Inputs Num: %s\" % len(input_name))\n            single_name = input_name\n            helper.log_info(f\"single_name: {single_name}\")\n\n        # Loop across all the data and output it in one big JSON object\n        headers = {\n            'Content-type': 'application/json',\n            'x-api-user': global_email,\n            'x-api-token': global_api_token,\n            'User-Agent': user_agent_string\n        }\n\n        url = (\n            f\"{api_host}/api/v0/corps/{global_corp_api_name}\"\n            f\"/sites/{site_name}/activity?\"\n            f\"from={from_time}&until={until_time}\"\n        )\n        loop = True\n\n        counter = 1\n        helper.log_info(\"Pulling results from Events API\")\n        all_events = []\n        while loop:\n            helper.log_info(\"Processing page %s\" % counter)\n            start_page = timer()\n            response_result, response_code, response_error = \\\n                get_request_data(url, headers)\n\n            pulled, request_details = check_response(\n                response_code,\n                response_error,\n                current_site=site_name,\n                from_time=from_time,\n                until_time=until_time\n            )\n\n            if not pulled and request_details[\"msg\"] != \"rate-limit\":\n                helper.log_error(\"Failed to pull results\")\n                helper.log_error(request_details)\n                exit()\n            if not pulled and request_details[\"msg\"] == \"rate-limit\":\n                helper.log_error(\"Rate Limit hit\")\n                helper.log_error(\"Retrying in 10 seconds\")\n                time.sleep(10)\n                break\n            else:\n                response = json.loads(response_result.text)\n\n            number_requests_per_page = len(response['data'])\n            helper.log_info(\n                f\"Number of Requests for Page: {number_requests_per_page}\"\n            )\n\n            for request in response['data']:\n                data = json.dumps(request)\n                data = json.loads(data)\n                all_events.append(data)\n\n            if \"next\" in response and \"uri\" in response['next']:\n                next_url = response['next']['uri']\n                if next_url == '':\n                    helper.log_info(\"Finished Page %s\" % counter)\n                    counter += 1\n                    end_page = timer()\n                    page_time = end_page - start_page\n                    page_time_result = round(page_time, 2)\n                    helper.log_info(\n                        f\"Total Page Time: {page_time_result} seconds\"\n                    )\n                    loop = False\n                else:\n                    url = api_host + next_url\n                    helper.log_info(\"Finished Page %s\" % counter)\n                    counter += 1\n                    end_page = timer()\n                    page_time = end_page - start_page\n                    page_time_result = round(page_time, 2)\n                    helper.log_info(\n                        f\"Total Page Time: {page_time_result} seconds\"\n                    )\n            else:\n                loop = False\n\n        total_requests = len(all_events)\n        helper.log_info(\"Total Events Pulled: %s\" % total_requests)\n        write_start = timer()\n        for current_event in all_events:\n            # helper.log_debug(current_event)\n            # helper.log_info(f\"data={event_data}\")\n            current_event = json.dumps(current_event)\n            if key is None:\n                source_type = helper.get_sourcetype()\n                helper.log_info(\"Concurrent Mode\")\n                source_type_info = type(source_type)\n                active_index = helper.get_output_index()\n                index_info = type(active_index)\n                single_name_info = type(single_name)\n                current_event_info = type(current_event)\n                helper.log_info(f\"source_type: {source_type}\")\n                helper.log_info(f\"source_type_info: {source_type_info}\")\n                helper.log_info(f\"index: {active_index}\")\n                helper.log_info(f\"index_info: {index_info}\")\n                helper.log_info(f\"single_name: {single_name}\")\n                helper.log_info(f\"single_name_info: {single_name_info}\")\n                helper.log_info(f\"current_event: {current_event}\")\n                helper.log_info(f\"current_event_info: {current_event_info}\")\n                event = helper.new_event(\n                    source=single_name,\n                    index=helper.get_output_index(),\n                    sourcetype=source_type,\n                    data=current_event\n                )\n            else:\n                indexes = helper.get_output_index()\n                current_index = indexes[key]\n                types = helper.get_sourcetype()\n                source_type = types[key]\n                single_name = single_name[0]\n                helper.log_info(\"Sequential Mode\")\n                helper.log_info(f\"source_type: {source_type}\")\n                helper.log_info(f\"index: {current_index}\")\n                helper.log_info(f\"single_name: {single_name}\")\n                helper.log_info(f\"current_event: {current_event}\")\n                event = helper.new_event(\n                    source=single_name,\n                    index=current_index,\n                    sourcetype=source_type,\n                    data=current_event\n                )\n\n            try:\n                ew.write_event(event)\n            except Exception as e:\n                raise e\n        write_end = timer()\n        write_time = write_end - write_start\n        write_time_result = round(write_time, 2)\n        helper.log_info(\"Total Event Output Time: %s seconds\"\n                        % write_time_result)\n\n    # If multiple inputs configured it creates an array of values and the\n    # script only gets called once per Input configuration\n\n    # host_test = helper.get_arg('Host')\n    # helper.log_info(\"Host: %s\" % host_test)\n    all_sites = helper.get_arg('site_api_name')\n    time_deltas = helper.get_arg('time_delta')\n    if type(all_sites) is dict:\n        helper.log_info(\"run_type: Sequential\")\n        for active_input in all_sites:\n            site = all_sites[active_input]\n            current_delta = int(time_deltas[active_input])\n            helper.log_info(\"site: %s\" % site)\n            pull_events(\n                key=active_input,\n                current_site=site,\n                delta=current_delta\n            )\n            helper.log_info(\"Finished Pulling Events for %s\" % site)\n    else:\n        helper.log_info(\"Run Type: Concurrent\")\n        site = helper.get_arg('site_api_name')\n        helper.log_info(\"site: %s\" % site)\n        pull_events(\n            current_site=site,\n            delta=int(time_deltas)\n        )\n        helper.log_info(\"Finished Pulling Events for %s\" % site)\n    end = timer()\n    total_time = end - start\n    time_result = round(total_time, 2)\n    helper.log_info(\"Total Script Time: %s seconds\" % time_result)", "customized_options": [{"name": "site_api_name", "value": "splunk-demo-server"}, {"name": "time_delta", "value": "300"}], "uuid": "294ad5bbdf92407b9a6785b46106152a", "sample_count": "2"}, {"index": "default", "sourcetype": "sigsci-requests", "interval": "300", "use_external_validation": true, "streaming_mode_xml": true, "name": "SigsciRequests", "title": "SigsciRequests", "description": "", "type": "customized", "parameters": [{"name": "time_delta", "label": "Time Delta in Seconds", "help_string": "This is the period of time that the Modular Input will pull. This should be the exact same as the Modular Input interval", "required": true, "format_type": "text", "default_value": "300", "placeholder": "300", "type": "text", "value": "300"}, {"name": "site_api_name", "label": "Site API Name", "help_string": "This is the API Name of the site to pull date from. This should not be a URL.", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "splunk-demo-server"}], "data_inputs_options": [{"type": "customized_var", "name": "time_delta", "title": "Time Delta in Seconds", "description": "This is the period of time that the Modular Input will pull. This should be the exact same as the Modular Input interval", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "300", "placeholder": "300"}, {"type": "customized_var", "name": "site_api_name", "title": "Site API Name", "description": "This is the API Name of the site to pull date from. This should not be a URL.", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}], "customized_options": [{"name": "time_delta", "value": "300"}, {"name": "site_api_name", "value": "splunk-demo-server"}], "code": "# encoding = utf-8\n\nimport time\nfrom datetime import datetime, timedelta\nfrom timeit import default_timer as timer\nimport requests\nimport calendar\nimport json\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n\n\n# def use_single_instance_mode():\n#     return True\n\n\ndef validate_input(helper, definition):\n    # This example accesses the modular input variable\n    site_name = definition.parameters.get('site_api_name', None)\n    if site_name is None or site_name == \"\":\n        msg = \"The site_name can not be empty\"\n        raise ValueError(\n            \"InvalidSiteName\",\n            msg\n        )\n    elif \"http\" in site_name:\n        msg = (\n            \"The site name is not the full URL it should be the \",\n            \"API Name of the site like 'my_example_site'\"\n        )\n        raise ValueError(\n            \"InvalidSiteName\",\n            msg\n        )\n    elif \" \" in site_name:\n        msg = (\n            \"The site name should be the API Name of the site like \",\n            \"not the Display Name. Example would be 'my_site_name' instead of \",\n            \"My Site Name\"\n        )\n        raise ValueError(\n            \"InvalidSiteName\",\n            msg\n        )\n    time_delta = definition.parameters.get('time_delta', None)\n    if time_delta is None or time_delta == \"\":\n        msg = \"The frequency can not be empty\"\n        raise ValueError(\n            \"InvalidFrequency\",\n            msg\n        )\n    else:\n        try:\n            int(time_delta)\n        except Exception as error:\n            msg = \"Time delta must be an integer\"\n            raise ValueError(\n                \"InvalidFrequency\",\n                msg\n            )\n    pass\n\n\ndef collect_events(helper, ew):\n    start = timer()\n    # loglevel = helper.get_log_level()\n    # Proxy setting configuration\n    # proxy_settings = helper.get_proxy()\n    global_email = helper.get_global_setting(\"email\")\n    global_api_token = helper.get_global_setting(\"api_token\")\n    global_corp_api_name = helper.get_global_setting(\"corp_api_name\")\n    api_host = 'https://dashboard.signalsciences.net'\n    helper.log_info(\"email: %s\" % global_email)\n    helper.log_info(\"corp: %s\" % global_corp_api_name)\n    python_requests_version = requests.__version__\n    user_agent_version = \"1.0.26\"\n    user_agent_string = (\n        f\"TA-sigsci-waf/{user_agent_version} \"\n        f\"(PythonRequests {python_requests_version})\"\n    )\n\n    def check_response(code, response_text, current_site=None,\n                       from_time=None, until_time=None):\n        success = False\n        site_name = current_site\n        base_msg = {\n            \"from\": from_time,\n            \"until\": until_time,\n            \"global_email\": global_email,\n            \"global_corp_api_name\": global_corp_api_name,\n            \"site_name\": site_name,\n            \"response_text\": response_text,\n            \"status_code\": code,\n        }\n        if code == 400:\n            if \"Rate limit exceeded\" in response_text:\n                base_msg[\"msg\"] = \"rate-limit\"\n            else:\n                base_msg[\"error\"] = \"BAD API Request\"\n                base_msg[\"msg\"] = \"bad-request\"\n        elif code == 500:\n            base_msg[\"error\"] = \"Internal Server Error\"\n            base_msg[\"msg\"] = \"internal-error\"\n        elif code == 401:\n            base_msg[\"error\"] = \"Unauthorized. Incorrect credentials or lack \" \\\n                                \"of permissions\"\n            base_msg[\"msg\"] = \"unauthorized\"\n        elif 400 <= code <= 599 and code != 400 and code != 500 and code != 401:\n            base_msg[\"error\"] = \"Unknown Error\"\n            base_msg[\"msg\"] = \"other-error\"\n        else:\n            success = True\n        return success, base_msg\n\n    def get_request_data(url, headers):\n        method = \"GET\"\n        response_raw = helper.send_http_request(\n            url,\n            method,\n            parameters=None,\n            payload=None,\n            headers=headers,\n            cookies=None,\n            verify=True,\n            cert=None,\n            timeout=None,\n            use_proxy=True\n        )\n        response_codee = response_raw.status_code\n        response_error = response_raw.text\n        return response_raw, response_codee, response_error\n\n    def pull_requests(current_site, delta, key=None):\n        site_name = current_site\n        until_time = datetime.utcnow() - timedelta(minutes=5)\n        until_time = until_time.replace(second=0, microsecond=0)\n        from_time = until_time - timedelta(minutes=delta)\n        until_time = calendar.timegm(until_time.utctimetuple())\n        from_time = calendar.timegm(from_time.utctimetuple())\n        from_time_friendly = datetime.fromtimestamp(from_time)\n        until_time_friendly = datetime.fromtimestamp(until_time)\n        helper.log_info(\"SiteName: %s\" % site_name)\n\n        helper.log_info(f\"Start Period: {from_time_friendly}\")\n        helper.log_info(f\"End Period: {until_time_friendly}\")\n\n\n        input_name = helper.get_input_stanza_names()\n        single_name = \"\"\n\n        if type(input_name) is dict and input_name > 1:\n            helper.log_info(\"Multi instance mode\")\n            for current_name in input_name:\n                single_name = current_name\n        else:\n            helper.log_info(\"Single instance mode\")\n            helper.log_info(\"Inputs: %s\" % input_name)\n            helper.log_info(\"Inputs Num: %s\" % len(input_name))\n            single_name = input_name\n            helper.log_info(f\"single_name: {single_name}\")\n\n        # Loop across all the data and output it in one big JSON object\n        headers = {\n            'Content-type': 'application/json',\n            'x-api-user': global_email,\n            'x-api-token': global_api_token,\n            'User-Agent': user_agent_string\n        }\n\n        url = (\n            f\"{api_host}/api/v0/corps/{global_corp_api_name}\"\n            f\"/sites/{site_name}/feed/requests?\"\n            f\"from={from_time}&until={until_time}\"\n        )\n        loop = True\n\n        counter = 1\n        helper.log_info(\"Pulling requests from requests API\")\n        all_requests = []\n        while loop:\n            helper.log_info(\"Processing page %s\" % counter)\n            start_page = timer()\n            response_result, response_code, response_error = \\\n                get_request_data(url, headers)\n\n            pulled, request_details = check_response(\n                response_code,\n                response_error,\n                current_site=site_name,\n                from_time=from_time,\n                until_time=until_time\n            )\n\n            if not pulled and request_details[\"msg\"] != \"rate-limit\":\n                helper.log_error(\"Failed to pull results\")\n                helper.log_error(request_details)\n                exit()\n            if not pulled and request_details[\"msg\"] == \"rate-limit\":\n                helper.log_error(\"Rate Limit hit\")\n                helper.log_error(\"Retrying in 10 seconds\")\n                time.sleep(10)\n                break\n            else:\n                response = json.loads(response_result.text)\n\n            number_requests_per_page = len(response['data'])\n            helper.log_info(\n                f\"Number of Requests for Page: {number_requests_per_page}\"\n            )\n\n            for request in response['data']:\n                data = json.dumps(request)\n                data = json.loads(data)\n                headers_to_fix = {\n                    'headersOut': data['headersOut'],\n                    'headersIn': data['headersIn']\n                }\n\n                new_format_out = {}\n\n                if not (headers_to_fix['headersOut'] is None):\n                    for out in headers_to_fix['headersOut']:\n                        new_format_out[out[0]] = out[1]\n\n                    data['headersOut'] = new_format_out\n\n                new_format_in = {}\n\n                if not (headers_to_fix['headersIn'] is None):\n                    for header_in in headers_to_fix['headersIn']:\n                        headers_to_fix[header_in[0]] = header_in[1]\n\n                    data['headersIn'] = headers_to_fix\n\n                data = json.dumps(data)\n\n                # helper.log_debug(\"%s\" % data)\n                all_requests.append(data)\n\n            if \"next\" in response and \"uri\" in response['next']:\n                next_url = response['next']['uri']\n                if next_url == '':\n                    helper.log_info(\"Finished Page %s\" % counter)\n                    counter += 1\n                    end_page = timer()\n                    page_time = end_page - start_page\n                    page_time_result = round(page_time, 2)\n                    helper.log_info(\n                        f\"Total Page Time: {page_time_result} seconds\"\n                    )\n                    loop = False\n                else:\n                    url = api_host + next_url\n                    helper.log_info(\"Finished Page %s\" % counter)\n                    counter += 1\n                    end_page = timer()\n                    page_time = end_page - start_page\n                    page_time_result = round(page_time, 2)\n                    helper.log_info(\n                        f\"Total Page Time: {page_time_result} seconds\"\n                    )\n            else:\n                loop = False\n\n        total_requests = len(all_requests)\n        helper.log_info(\"Total Requests Pulled: %s\" % total_requests)\n        write_start = timer()\n        for current_event in all_requests:\n            # helper.log_debug(current_event)\n            # helper.log_info(f\"data={event_data}\")\n            if key is None:\n                # helper.log_info(\"input_type=single\")\n                source_index = helper.get_output_index()\n                source_type = helper.get_sourcetype()\n                # helper.log_info(f\"source={single_name}\")\n                # helper.log_info(f\"index={source_index}\")\n                # helper.log_info(f\"source_type={source_type}\")\n                event = helper.new_event(\n                    source=single_name,\n                    index=helper.get_output_index(),\n                    sourcetype=source_type,\n                    data=current_event\n                )\n            else:\n                # helper.log_info(\"input_type=multi\")\n                indexes = helper.get_output_index()\n                current_index = indexes[key]\n                types = helper.get_sourcetype()\n                source_type = types[key]\n                single_name = single_name[0]\n                event = helper.new_event(\n                    source=single_name,\n                    index=current_index,\n                    sourcetype=source_type,\n                    data=current_event\n                )\n\n            try:\n                ew.write_event(event)\n            except Exception as e:\n                helper.log_error(event)\n                raise e\n        write_end = timer()\n        write_time = write_end - write_start\n        write_time_result = round(write_time, 2)\n        helper.log_info(\"Total Event Output Time: %s seconds\"\n                        % write_time_result)\n\n    # If multiple inputs configured it creates an array of values and the\n    # script only gets called once per Input configuration\n\n    # host_test = helper.get_arg('Host')\n    # helper.log_info(\"Host: %s\" % host_test)\n    all_sites = helper.get_arg('site_api_name')\n    time_deltas = helper.get_arg('time_delta')\n    if type(all_sites) is dict:\n        helper.log_info(\"run_type: Sequential\")\n        for active_input in all_sites:\n            site = all_sites[active_input]\n            time_delta = int(time_deltas[active_input])\n            helper.log_info(\"site: %s\" % site)\n            pull_requests(\n                key=active_input,\n                current_site=site,\n                delta=time_delta\n            )\n            helper.log_info(\"Finished Pulling Requests for %s\" % site)\n    else:\n        helper.log_info(\"Run Type: Concurrent\")\n        site = helper.get_arg('site_api_name')\n        helper.log_info(\"site: %s\" % site)\n        pull_requests(\n            current_site=site,\n            delta=int(time_deltas)\n        )\n        helper.log_info(\"Finished Pulling Requests for %s\" % site)\n    end = timer()\n    total_time = end - start\n    time_result = round(total_time, 2)\n    helper.log_info(\"Total Script Time: %s seconds\" % time_result)", "uuid": "aaaeb391da9043e1819408033d9db708", "sample_count": "13063"}, {"index": "default", "sourcetype": "sigsci-activity", "interval": "300", "use_external_validation": true, "streaming_mode_xml": true, "name": "SigsciActivity", "title": "SigsciActivity", "description": "", "type": "customized", "parameters": [{"name": "time_delta", "label": "Time Delta in seconds", "help_string": "This is the time period of events that the Modular Input will pull. This should be the exact same as the Moduler Input interval.", "required": true, "format_type": "text", "default_value": "300", "placeholder": "300", "type": "text", "value": "300"}], "data_inputs_options": [{"type": "customized_var", "name": "time_delta", "title": "Time Delta in seconds", "description": "This is the time period of events that the Modular Input will pull. This should be the exact same as the Moduler Input interval.", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "300", "placeholder": "300"}], "code": "# encoding = utf-8\n\nimport time\nfrom datetime import datetime, timedelta\nfrom timeit import default_timer as timer\nimport requests\nimport calendar\nimport json\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n\n\n# def use_single_instance_mode():\n#     return True\n\n\ndef validate_input(helper, definition):\n    # This example accesses the modular input variable\n    time_delta = definition.parameters.get('time_delta', None)\n    if time_delta is None or time_delta == \"\":\n        msg = \"The frequency can not be empty\"\n        raise ValueError(\n            \"InvalidFrequency\",\n            msg\n        )\n    else:\n        try:\n            int(time_delta)\n        except Exception as error:\n            msg = \"Time delta must be an integer\"\n            raise ValueError(\n                \"InvalidFrequency\",\n                msg\n            )\n    pass\n\n\ndef collect_events(helper, ew):\n    start = timer()\n    # loglevel = helper.get_log_level()\n    # Proxy setting configuration\n    # proxy_settings = helper.get_proxy()\n    global_email = helper.get_global_setting(\"email\")\n    global_api_token = helper.get_global_setting(\"api_token\")\n    global_corp_api_name = helper.get_global_setting(\"corp_api_name\")\n    api_host = 'https://dashboard.signalsciences.net'\n    helper.log_info(\"email: %s\" % global_email)\n    helper.log_info(\"corp: %s\" % global_corp_api_name)\n    python_requests_version = requests.__version__\n    user_agent_version = \"1.0.26\"\n    user_agent_string = (\n        f\"TA-sigssci-waf/{user_agent_version} \"\n        f\"(PythonRequests {python_requests_version})\"\n    )\n\n    def check_response(code, response_text, from_time=None, until_time=None):\n        success = False\n        base_msg = {\n            \"from\": from_time,\n            \"until\": until_time,\n            \"global_email\": global_email,\n            \"global_corp_api_name\": global_corp_api_name,\n            \"response_text\": response_text,\n            \"status_code\": code,\n        }\n        if code == 400:\n            if \"Rate limit exceeded\" in response_text:\n                base_msg[\"msg\"] = \"rate-limit\"\n            else:\n                base_msg[\"error\"] = \"BAD API Request\"\n                base_msg[\"msg\"] = \"bad-request\"\n        elif code == 500:\n            base_msg[\"error\"] = \"Internal Server Error\"\n            base_msg[\"msg\"] = \"internal-error\"\n        elif code == 401:\n            base_msg[\"error\"] = \"Unauthorized. Incorrect credentials or lack \" \\\n                                \"of permissions\"\n            base_msg[\"msg\"] = \"unauthorized\"\n        elif 400 <= code <= 599 and code != 400 and code != 500 and code != 401:\n            base_msg[\"error\"] = \"Unknown Error\"\n            base_msg[\"msg\"] = \"other-error\"\n        else:\n            success = True\n        return success, base_msg\n\n    def get_request_data(url, headers):\n        method = \"GET\"\n        response_raw = helper.send_http_request(\n            url,\n            method,\n            parameters=None,\n            payload=None,\n            headers=headers,\n            cookies=None,\n            verify=True,\n            cert=None,\n            timeout=None,\n            use_proxy=True\n        )\n        response_codee = response_raw.status_code\n        response_error = response_raw.text\n        return response_raw, response_codee, response_error\n\n    def pull_events(delta, key=None):\n        until_time = datetime.utcnow()\n        until_time = until_time.replace(second=0, microsecond=0)\n        from_time = until_time - timedelta(seconds=delta)\n        until_time = calendar.timegm(until_time.utctimetuple())\n        from_time = calendar.timegm(from_time.utctimetuple())\n        from_time_friendly = datetime.fromtimestamp(from_time)\n        until_time_friendly = datetime.fromtimestamp(until_time)\n\n        helper.log_info(f\"Start Period: {from_time_friendly}\")\n        helper.log_info(f\"End Period: {until_time_friendly}\")\n\n        input_name = helper.get_input_stanza_names()\n        single_name = \"\"\n\n        if type(input_name) is dict and input_name > 1:\n            helper.log_info(\"Multi instance mode\")\n            for current_name in input_name:\n                single_name = current_name\n        else:\n            helper.log_info(\"Single instance mode\")\n            helper.log_info(\"Inputs: %s\" % input_name)\n            helper.log_info(\"Inputs Num: %s\" % len(input_name))\n            single_name = input_name\n            helper.log_info(f\"single_name: {single_name}\")\n\n        # Loop across all the data and output it in one big JSON object\n        headers = {\n            'Content-type': 'application/json',\n            'x-api-user': global_email,\n            'x-api-token': global_api_token,\n            'User-Agent': user_agent_string\n        }\n\n        url = (\n            f\"{api_host}/api/v0/corps/{global_corp_api_name}\"\n            f\"/activity?\"\n            f\"from={from_time}&until={until_time}\"\n        )\n        loop = True\n\n        counter = 1\n        helper.log_info(\"Pulling results from Corp Activity API\")\n        all_events = []\n        while loop:\n            helper.log_info(\"Processing page %s\" % counter)\n            start_page = timer()\n            response_result, response_code, response_error = \\\n                get_request_data(url, headers)\n\n            pulled, request_details = check_response(\n                response_code,\n                response_error,\n                from_time=from_time,\n                until_time=until_time\n            )\n\n            if not pulled and request_details[\"msg\"] != \"rate-limit\":\n                helper.log_error(\"Failed to pull results\")\n                helper.log_error(request_details)\n                exit()\n            if not pulled and request_details[\"msg\"] == \"rate-limit\":\n                helper.log_error(\"Rate Limit hit\")\n                helper.log_error(\"Retrying in 10 seconds\")\n                time.sleep(10)\n                break\n            else:\n                response = json.loads(response_result.text)\n\n            number_requests_per_page = len(response['data'])\n            helper.log_info(\n                f\"Number of Requests for Page: {number_requests_per_page}\"\n            )\n\n            for request in response['data']:\n                data = json.dumps(request)\n                data = json.loads(data)\n                all_events.append(data)\n\n            if \"next\" in response and \"uri\" in response['next']:\n                next_url = response['next']['uri']\n                if next_url == '':\n                    helper.log_info(\"Finished Page %s\" % counter)\n                    counter += 1\n                    end_page = timer()\n                    page_time = end_page - start_page\n                    page_time_result = round(page_time, 2)\n                    helper.log_info(\n                        f\"Total Page Time: {page_time_result} seconds\"\n                    )\n                    loop = False\n                else:\n                    url = api_host + next_url\n                    helper.log_info(\"Finished Page %s\" % counter)\n                    counter += 1\n                    end_page = timer()\n                    page_time = end_page - start_page\n                    page_time_result = round(page_time, 2)\n                    helper.log_info(\n                        f\"Total Page Time: {page_time_result} seconds\"\n                    )\n            else:\n                loop = False\n\n        total_requests = len(all_events)\n        helper.log_info(\"Total Corp Activity Pulled: %s\" % total_requests)\n        write_start = timer()\n        for current_event in all_events:\n            # helper.log_debug(current_event)\n            # helper.log_info(f\"data={event_data}\")\n            current_event = json.dumps(current_event)\n            if key is None:\n                source_type = helper.get_sourcetype()\n                helper.log_info(\"Concurrent Mode\")\n                source_type_info = type(source_type)\n                active_index = helper.get_output_index()\n                index_info = type(active_index)\n                single_name_info = type(single_name)\n                current_event_info = type(current_event)\n                helper.log_info(f\"source_type: {source_type}\")\n                helper.log_info(f\"source_type_info: {source_type_info}\")\n                helper.log_info(f\"index: {active_index}\")\n                helper.log_info(f\"index_info: {index_info}\")\n                helper.log_info(f\"single_name: {single_name}\")\n                helper.log_info(f\"single_name_info: {single_name_info}\")\n                helper.log_info(f\"current_event: {current_event}\")\n                helper.log_info(f\"current_event_info: {current_event_info}\")\n                event = helper.new_event(\n                    source=single_name,\n                    index=helper.get_output_index(),\n                    sourcetype=source_type,\n                    data=current_event\n                )\n            else:\n                indexes = helper.get_output_index()\n                current_index = indexes[key]\n                types = helper.get_sourcetype()\n                source_type = types[key]\n                single_name = single_name[0]\n                helper.log_info(\"Sequential Mode\")\n                helper.log_info(f\"source_type: {source_type}\")\n                helper.log_info(f\"index: {current_index}\")\n                helper.log_info(f\"single_name: {single_name}\")\n                helper.log_info(f\"current_event: {current_event}\")\n                event = helper.new_event(\n                    source=single_name,\n                    index=current_index,\n                    sourcetype=source_type,\n                    data=current_event\n                )\n\n            try:\n                ew.write_event(event)\n            except Exception as e:\n                raise e\n        write_end = timer()\n        write_time = write_end - write_start\n        write_time_result = round(write_time, 2)\n        helper.log_info(\n            f\"Total Corp Activity Output Time: {write_time_result} seconds\"\n        )\n\n    # If multiple inputs configured it creates an array of values and the\n    # script only gets called once per Input configuration\n    time_deltas = helper.get_arg('time_delta')\n    if type(time_deltas) is dict:\n        helper.log_info(\"run_type: Sequential\")\n        for active_input in time_deltas:\n            time_delta = time_deltas[active_input]\n            time_delta = int(time_delta)\n            helper.log_info(\"time_delta: %s\" % time_delta)\n            pull_events(\n                delta=time_delta,\n                key=active_input\n            )\n    else:\n        helper.log_info(\"Run Type: Concurrent\")\n        helper.log_info(\"time_delta: %s\" % time_deltas)\n        pull_events(\n            delta=int(time_deltas)\n        )\n    helper.log_info(\"Finished Pulling Corp Activity\")\n    end = timer()\n    total_time = end - start\n    time_result = round(total_time, 2)\n    helper.log_info(f\"Total Script Time: {time_result} seconds\")\n", "customized_options": [{"name": "time_delta", "value": "300"}], "uuid": "07b37d1943e942cf831c8ee85ffcb4a2", "sample_count": "1"}]}, "field_extraction_builder": {"sigsci-requests": {"is_parsed": true, "data_format": "json"}, "sigsci-event": {"is_parsed": true, "data_format": "json"}, "sigsci-activity": {"is_parsed": true, "data_format": "json"}}, "global_settings_builder": {"global_settings": {"proxy_settings": {"proxy_type": "http"}, "log_settings": {"log_level": "DEBUG"}, "customized_settings": [{"required": true, "name": "email", "label": "E-mail", "default_value": "", "placeholder": "example@example.com", "help_string": "This it the e-mail username of the user who has the correct permissions for the app to pull the data.", "type": "text", "format_type": "text", "value": "dacoburn@dactbc.com"}, {"required": true, "name": "corp_api_name", "label": "Corp", "default_value": "", "placeholder": "", "help_string": "This is the API name of your corp.", "type": "text", "format_type": "text", "value": "dactbc"}, {"required": true, "name": "api_token", "label": "API Token", "placeholder": "", "default_value": "", "help_string": "This is the API Token of the user who has the correct permissions. The API Token is tied to the username.", "type": "password", "format_type": "password", "value": ""}]}}, "sourcetype_builder": {"sigsci-requests": {"metadata": {"event_count": 0, "data_input_name": "SigsciRequests", "extractions_count": 0, "cims_count": 0}}, "sigsci-event": {"metadata": {"event_count": 0, "data_input_name": "SigsciEvent", "extractions_count": 0, "cims_count": 0}}, "sigsci-activity": {"metadata": {"event_count": 0, "data_input_name": "SigsciActivity", "extractions_count": 0, "cims_count": 0}}}, "validation": {"validators": ["best_practice_validation", "data_model_mapping_validation", "field_extract_validation", "app_cert_validation"], "status": "job_finished", "validation_id": "v_1675752275_27", "progress": 1.0}}