{"basic_builder": {"appname": "sigsci_TA_for_splunk", "friendly_name": "Signal Sciences WAF TA", "version": "1.0.32", "author": "Fastly", "description": "For users of Fastly who would like to enrich their Splunk data with information from Fastly. This app with simple configuration enabled the importing of Events, Activity, and raw request information to Splunk.\n\nThis is an open source project, no support provided, public repository is available and installation documentation can be found at https://github.com/fastly/sigsci-splunk-app. The best way to report issues with the app is to create an Issue on the github page so that it can be tracked.", "theme": "#f07a35", "large_icon": "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", "small_icon": "iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAAXNSR0IArs4c6QAABiNJREFUWEetWFtIVF0U/s6Zm859JCV8SoKgjMS0C0SUFQVJYQSlFUlJ9eBDZBFB+Wag9FJSkRQGQuRb9hDdKI2E/JUopKwISoiIUObijHN1zv75tjq/l3Eu+u+nxTlrr7X2Wmt/a62tCCGEpmnw+XxwuVyIRqMYHx+XNJfH44HVaoXBYEjQWm8vTHv2yP8Lru/f4bHb5W/KCoVCCIfDkh4bG0M8Hpe0EAJerxdOpxMTExNQAoGAUBQFer0esVgMqqpCp9NJmouGkJEbSVOQ6O2FeffulPaEhoagW7lS8lAWZVI2aeqiTtLTuqUxigLF6/UKMprNZgQCAanUZDJJmove4eloCGmekputT59CV1OT1KjIq1cIl5VJfi7KokzKJk1d1EmaRlgsFhkVGq0sJmQUHOroQG5tbXKDnjyBae9eGeKsQ+Z2u6WHHA6HFGA0GqXFM4X5/X7pFcacp6KrbY8eQV9Xl9Sg8IsXCJWXz8rD3Nxc5OTkSLk2m02GjTQ9xPxhHslQRiIROkkq5AfSDA+9MDP+IhqF6fRpqF1dQCSSOqGn/xoM0KqqELl3j8kIXp65OTlXd9qQBd6+haW2FsrPn5kZsQCXKCzEeGcnrFu3pr5lC4ZsZASOykqoAwNLMmTuZm3dOoh//oFuKnzzQhaPx2XImCd2u13mB2+Vc/nyzEOTrcmqCt/fv7Dl5cmdxCXmFVNlPg719yN31y5A07JVkzV/uLsb2saNMncTODQzZL7hYTiKirIWvJQN/k+fYCsu/u+WJXDI7YaroAAQYinys9+rKPD++QNHQcGklxJIvW8fdG/eZCxQ27AB0Y4OhJ1OOM6cQVzTEGhvhzMYhHboENT+/sxllZYi0NMzidQej0cotHDNmowERI8fR/DGDQmkLCORSETSTEiCJmmelKXAfv481Pb2jOT6BgehKyqaLB1QlIw2BZubYWhoSFR+Ii8RmIjL0/GWkmaS8taQNj18CHN9fUbyY9EoFPfoqHAtW5Z2Q+TmTZjq6xOlY25LQa8QOvh9Ji2La08PrBUVaXWMu91Q4leuCLWpKSWztn49MDAgFdIj9ABp1j1WcdL0EKu4xLMtW6C9e4fAFHTQW1plJfTPnqXUE6urgxKrqBD67u6UjBPd3dBv3z6vWZsbMjYbKvPp8GHoOjtnFejYly8wpMnTeFkZFC0vTyhu98IG6XTwezzzqv3MkDmGhoDRUahVVdBqaqB1dCTCR8HMJVnt2UFONX7JFAqHA4owmwWCwYUNMpkQ+/oVhhUrknrIeOAAdM+fy/3RixcxfunSrKTmdxof/vEDOWvXAqHQwrpyczMwSFWhbduG8cePZT/DnpttBGkmb05hIcFMKmHTpq+ulv/JRx4uwoNlxw6o79+nBV5FOBwCPt/CVhuN8I+OLhiy6K9fsNy+DaWkBGNVVUlvWSJkTmfqgm02Q5nYvFno+vpSZ7/bDYPLlTapk+FQImQ+H3I4yaQoTdrq1VAiR48K44MHKQ2KnDqFYEvLrBY2GxySo1RjIwy3bqWGl8pKKL7Pn4W9uDgtaPm+fYNj1apFAaN3eBjODLqI8IcP2ZUO7+/fsOTnZ1U6ZMjy84F4PO2hJ0uH2y2M3d2wHDyYdgNrXuD1a8RKSuZNo8lKh21kBHqCYQbGjLe1QRw5MjWXxeNQOdSFw+mNAiBsNoz19UlsYrmInjsHPWW0tsrEN4yOwlJeDmVsLCN5MBohQiFMsIWdbtACg4Owl5ZmJmCaS1EgXC4oU2AnCGwcDrNs8gIvX8Kyc+dkgzazhY00NcHU2JidUUvkJrobW1qStLBTrx/ayZNQ799foprMtov9+4GurtmvH36/X75+cKIk3HOszmlogNrWlpnURXJp1dUI3r0rd7ONmX4JmRWymbP9WH8/7Js2LVJd6m3i40dZapLO9qleP1gkY5cvw9Tc/L8YFj17FoZr1+Cfet5J+mCVyetHgFf5wgWYOjqAiYmsjYucOAG0tsJktaZ//Zgeg/gEw/aTucS2gTQX289gMCinCtIcs03Xr0O9c4djLxT2UtNTLmHAYoGwWiGOHYNy9aqUQVlsdZkrpIldbHlJM3/5sMWJhd/+BXe3XAACKxnuAAAAAElFTkSuQmCC", "visible": true, "tab_version": "4.1.1", "tab_build_no": "0", "build_no": 9}, "data_input_builder": {"datainputs": [{"index": "default", "sourcetype": "sigsci-event", "interval": "300", "use_external_validation": true, "streaming_mode_xml": true, "name": "SigsciEvent", "title": "SigsciEvent", "description": "", "type": "customized", "parameters": [{"name": "site_api_name", "label": "Site API Name", "help_string": "This is the Site API Name. It should not be a URL.", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "splunk-demo-server"}], "data_inputs_options": [{"type": "customized_var", "name": "site_api_name", "title": "Site API Name", "description": "This is the Site API Name. It should not be a URL.", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}], "code": "# encoding = utf-8\r\n\r\nimport time\r\nfrom datetime import datetime, timedelta\r\nfrom timeit import default_timer as timer\r\nimport requests\r\nimport calendar\r\nimport json\r\nfrom sigsci_helper import check_response, get_request_data\r\n\r\n'''\r\n    IMPORTANT\r\n    Edit only the validate_input and collect_events functions.\r\n    Do not edit any other part in this file.\r\n    This file is generated only once when creating the modular input.\r\n'''\r\n\r\n\r\n# def use_single_instance_mode():\r\n#     return True\r\n\r\n\r\ndef validate_input(helper, definition):\r\n    # This example accesses the modular input variable\r\n    site_name = definition.parameters.get('site_api_name', None)\r\n    if site_name is None or site_name == \"\":\r\n        msg = \"The site_name can not be empty\"\r\n        raise ValueError(\r\n            \"InvalidSiteName\",\r\n            msg\r\n        )\r\n    elif \"http\" in site_name:\r\n        msg = (\r\n            \"The site name is not the full URL it should be the \",\r\n            \"API Name of the site like 'my_example_site'\"\r\n        )\r\n        raise ValueError(\r\n            \"InvalidSiteName\",\r\n            msg\r\n        )\r\n    elif \" \" in site_name:\r\n        msg = (\r\n            \"The site name should be the API Name of the site like \",\r\n            \"not the Display Name. Example would be 'my_site_name' instead of \",\r\n            \"My Site Name\"\r\n        )\r\n        raise ValueError(\r\n            \"InvalidSiteName\",\r\n            msg\r\n        )\r\n    pass\r\n\r\n\r\ndef collect_events(helper, ew):\r\n    start = timer()\r\n    # loglevel = helper.get_log_level()\r\n    # Proxy setting configuration\r\n    # proxy_settings = helper.get_proxy()\r\n    global_email = helper.get_global_setting(\"email\")\r\n    global_api_token = helper.get_global_setting(\"api_token\")\r\n    global_corp_api_name = helper.get_global_setting(\"corp_api_name\")\r\n    api_host = 'https://dashboard.signalsciences.net'\r\n    helper.log_info(\"email: %s\" % global_email)\r\n    helper.log_info(\"corp: %s\" % global_corp_api_name)\r\n    python_requests_version = requests.__version__\r\n    user_agent_version = \"1.0.26\"\r\n    user_agent_string = (\r\n        f\"TA-sigsci-waf/{user_agent_version} \"\r\n        f\"(PythonRequests {python_requests_version})\"\r\n    )\r\n\r\n    def pull_events(current_site, delta, key=None):\r\n        site_name = current_site\r\n        until_time = datetime.utcnow()\r\n        until_time = until_time.replace(second=0, microsecond=0)\r\n        from_time = until_time - timedelta(seconds=delta)\r\n        until_time = calendar.timegm(until_time.utctimetuple())\r\n        from_time = calendar.timegm(from_time.utctimetuple())\r\n        from_time_friendly = datetime.fromtimestamp(from_time)\r\n        until_time_friendly = datetime.fromtimestamp(until_time)\r\n        helper.log_info(\"SiteName: %s\" % site_name)\r\n\r\n        helper.log_info(f\"Start Period: {from_time_friendly}\")\r\n        helper.log_info(f\"End Period: {until_time_friendly}\")\r\n\r\n\r\n        input_name = helper.get_input_stanza_names()\r\n        single_name = \"\"\r\n\r\n        if type(input_name) is dict and input_name > 1:\r\n            helper.log_info(\"Multi instance mode\")\r\n            for current_name in input_name:\r\n                single_name = current_name\r\n        else:\r\n            helper.log_info(\"Single instance mode\")\r\n            helper.log_info(\"Inputs: %s\" % input_name)\r\n            helper.log_info(\"Inputs Num: %s\" % len(input_name))\r\n            single_name = input_name\r\n            helper.log_info(f\"single_name: {single_name}\")\r\n\r\n        # Loop across all the data and output it in one big JSON object\r\n        headers = {\r\n            'Content-type': 'application/json',\r\n            'x-api-user': global_email,\r\n            'x-api-token': global_api_token,\r\n            'User-Agent': user_agent_string\r\n        }\r\n\r\n        url = (\r\n            f\"{api_host}/api/v0/corps/{global_corp_api_name}\"\r\n            f\"/sites/{site_name}/activity?\"\r\n            f\"from={from_time}&until={until_time}\"\r\n        )\r\n        loop = True\r\n\r\n        counter = 1\r\n        helper.log_info(\"Pulling results from Events API\")\r\n        all_events = []\r\n        while loop:\r\n            helper.log_info(\"Processing page %s\" % counter)\r\n            start_page = timer()\r\n            response_result, response_code, response_error = \\\r\n                get_request_data(url, headers, helper)\r\n\r\n            pulled, request_details = check_response(\r\n                response_code,\r\n                response_error,\r\n                global_email=global_email,\r\n                global_corp_api_name=global_corp_api_name,\r\n                current_site=site_name,\r\n                from_time=from_time,\r\n                until_time=until_time\r\n            )\r\n\r\n            if not pulled and request_details[\"msg\"] != \"rate-limit\":\r\n                helper.log_error(\"Failed to pull results\")\r\n                helper.log_error(request_details)\r\n                exit()\r\n            if not pulled and request_details[\"msg\"] == \"rate-limit\":\r\n                helper.log_error(\"Rate Limit hit\")\r\n                helper.log_error(\"Retrying in 10 seconds\")\r\n                time.sleep(10)\r\n                break\r\n            else:\r\n                response = response_result\r\n\r\n            number_requests_per_page = len(response['data'])\r\n            helper.log_info(\r\n                f\"Number of Requests for Page: {number_requests_per_page}\"\r\n            )\r\n\r\n            for request in response['data']:\r\n                data = json.dumps(request)\r\n                data = json.loads(data)\r\n                all_events.append(data)\r\n\r\n            if \"next\" in response and \"uri\" in response['next']:\r\n                next_url = response['next']['uri']\r\n                if next_url == '':\r\n                    helper.log_info(\"Finished Page %s\" % counter)\r\n                    counter += 1\r\n                    end_page = timer()\r\n                    page_time = end_page - start_page\r\n                    page_time_result = round(page_time, 2)\r\n                    helper.log_info(\r\n                        f\"Total Page Time: {page_time_result} seconds\"\r\n                    )\r\n                    loop = False\r\n                else:\r\n                    url = api_host + next_url\r\n                    helper.log_info(\"Finished Page %s\" % counter)\r\n                    counter += 1\r\n                    end_page = timer()\r\n                    page_time = end_page - start_page\r\n                    page_time_result = round(page_time, 2)\r\n                    helper.log_info(\r\n                        f\"Total Page Time: {page_time_result} seconds\"\r\n                    )\r\n            else:\r\n                loop = False\r\n\r\n        total_requests = len(all_events)\r\n        helper.log_info(\"Total Events Pulled: %s\" % total_requests)\r\n        write_start = timer()\r\n        for current_event in all_events:\r\n            # helper.log_debug(current_event)\r\n            # helper.log_info(f\"data={event_data}\")\r\n            current_event = json.dumps(current_event)\r\n            if key is None:\r\n                source_type = helper.get_sourcetype()\r\n                helper.log_info(\"Concurrent Mode\")\r\n                source_type_info = type(source_type)\r\n                active_index = helper.get_output_index()\r\n                index_info = type(active_index)\r\n                single_name_info = type(single_name)\r\n                current_event_info = type(current_event)\r\n                helper.log_info(f\"source_type: {source_type}\")\r\n                helper.log_info(f\"source_type_info: {source_type_info}\")\r\n                helper.log_info(f\"index: {active_index}\")\r\n                helper.log_info(f\"index_info: {index_info}\")\r\n                helper.log_info(f\"single_name: {single_name}\")\r\n                helper.log_info(f\"single_name_info: {single_name_info}\")\r\n                helper.log_info(f\"current_event: {current_event}\")\r\n                helper.log_info(f\"current_event_info: {current_event_info}\")\r\n                event = helper.new_event(\r\n                    source=single_name,\r\n                    index=helper.get_output_index(),\r\n                    sourcetype=source_type,\r\n                    data=current_event\r\n                )\r\n            else:\r\n                indexes = helper.get_output_index()\r\n                current_index = indexes[key]\r\n                types = helper.get_sourcetype()\r\n                source_type = types[key]\r\n                single_name = single_name[0]\r\n                helper.log_info(\"Sequential Mode\")\r\n                helper.log_info(f\"source_type: {source_type}\")\r\n                helper.log_info(f\"index: {current_index}\")\r\n                helper.log_info(f\"single_name: {single_name}\")\r\n                helper.log_info(f\"current_event: {current_event}\")\r\n                event = helper.new_event(\r\n                    source=single_name,\r\n                    index=current_index,\r\n                    sourcetype=source_type,\r\n                    data=current_event\r\n                )\r\n\r\n            try:\r\n                ew.write_event(event)\r\n            except Exception as e:\r\n                raise e\r\n        write_end = timer()\r\n        write_time = write_end - write_start\r\n        write_time_result = round(write_time, 2)\r\n        helper.log_info(\"Total Event Output Time: %s seconds\"\r\n                        % write_time_result)\r\n\r\n    # If multiple inputs configured it creates an array of values and the\r\n    # script only gets called once per Input configuration\r\n\r\n    # host_test = helper.get_arg('Host')\r\n    # helper.log_info(\"Host: %s\" % host_test)\r\n    all_sites = helper.get_arg('site_api_name')\r\n    time_deltas = helper.get_arg('interval')\r\n    helper.log_info(f\"interval: {time_deltas}\")\r\n    if type(all_sites) is dict:\r\n        helper.log_info(\"run_type: Sequential\")\r\n        for active_input in all_sites:\r\n            site = all_sites[active_input]\r\n            current_delta = int(time_deltas[active_input])\r\n            helper.log_info(\"site: %s\" % site)\r\n            pull_events(\r\n                key=active_input,\r\n                current_site=site,\r\n                delta=current_delta\r\n            )\r\n            helper.log_info(\"Finished Pulling Events for %s\" % site)\r\n    else:\r\n        helper.log_info(\"Run Type: Concurrent\")\r\n        site = helper.get_arg('site_api_name')\r\n        helper.log_info(\"site: %s\" % site)\r\n        pull_events(\r\n            current_site=site,\r\n            delta=int(time_deltas)\r\n        )\r\n        helper.log_info(\"Finished Pulling Events for %s\" % site)\r\n    end = timer()\r\n    total_time = end - start\r\n    time_result = round(total_time, 2)\r\n    helper.log_info(\"Total Script Time: %s seconds\" % time_result)", "customized_options": [{"name": "site_api_name", "value": "splunk-demo-server"}], "uuid": "294ad5bbdf92407b9a6785b46106152a", "sample_count": "3"}, {"index": "default", "sourcetype": "sigsci-activity", "interval": "300", "use_external_validation": true, "streaming_mode_xml": true, "name": "SigsciActivity", "title": "SigsciActivity", "description": "", "type": "customized", "parameters": [{"required": false, "name": "place_holder", "label": "Place Holder", "default_value": "", "placeholder": "Not needed", "help_string": "It was required to have one option even if it isn't needed. You can skip this one.", "type": "text", "format_type": "text", "value": ""}], "data_inputs_options": [{"type": "customized_var", "name": "place_holder", "title": "Place Holder", "description": "It was required to have one option even if it isn't needed. You can skip this one.", "required_on_edit": false, "required_on_create": false, "format_type": "text", "default_value": "", "placeholder": "Not needed"}], "code": "# encoding = utf-8\r\n\r\nimport time\r\nfrom datetime import datetime, timedelta\r\nfrom timeit import default_timer as timer\r\nimport requests\r\nimport calendar\r\nimport json\r\nfrom sigsci_helper import check_response, get_request_data\r\n\r\n'''\r\n    IMPORTANT\r\n    Edit only the validate_input and collect_events functions.\r\n    Do not edit any other part in this file.\r\n    This file is generated only once when creating the modular input.\r\n'''\r\n\r\n\r\n# def use_single_instance_mode():\r\n#     return True\r\n\r\n\r\ndef validate_input(helper, definition):\r\n    # This example accesses the modular input variable\r\n    pass\r\n\r\n\r\ndef collect_events(helper, ew):\r\n    start = timer()\r\n    # loglevel = helper.get_log_level()\r\n    # Proxy setting configuration\r\n    # proxy_settings = helper.get_proxy()\r\n    global_email = helper.get_global_setting(\"email\")\r\n    global_api_token = helper.get_global_setting(\"api_token\")\r\n    global_corp_api_name = helper.get_global_setting(\"corp_api_name\")\r\n    api_host = 'https://dashboard.signalsciences.net'\r\n    helper.log_info(\"email: %s\" % global_email)\r\n    helper.log_info(\"corp: %s\" % global_corp_api_name)\r\n    python_requests_version = requests.__version__\r\n    user_agent_version = \"1.0.26\"\r\n    user_agent_string = (\r\n        f\"TA-sigssci-waf/{user_agent_version} \"\r\n        f\"(PythonRequests {python_requests_version})\"\r\n    )\r\n\r\n    def pull_events(delta, key=None):\r\n        until_time = datetime.utcnow()\r\n        until_time = until_time.replace(second=0, microsecond=0)\r\n        from_time = until_time - timedelta(seconds=delta)\r\n        until_time = calendar.timegm(until_time.utctimetuple())\r\n        from_time = calendar.timegm(from_time.utctimetuple())\r\n        from_time_friendly = datetime.fromtimestamp(from_time)\r\n        until_time_friendly = datetime.fromtimestamp(until_time)\r\n\r\n        helper.log_info(f\"Start Period: {from_time_friendly}\")\r\n        helper.log_info(f\"End Period: {until_time_friendly}\")\r\n\r\n        input_name = helper.get_input_stanza_names()\r\n        single_name = \"\"\r\n\r\n        if type(input_name) is dict and input_name > 1:\r\n            helper.log_info(\"Multi instance mode\")\r\n            for current_name in input_name:\r\n                single_name = current_name\r\n        else:\r\n            helper.log_info(\"Single instance mode\")\r\n            helper.log_info(\"Inputs: %s\" % input_name)\r\n            helper.log_info(\"Inputs Num: %s\" % len(input_name))\r\n            single_name = input_name\r\n            helper.log_info(f\"single_name: {single_name}\")\r\n\r\n        # Loop across all the data and output it in one big JSON object\r\n        headers = {\r\n            'Content-type': 'application/json',\r\n            'x-api-user': global_email,\r\n            'x-api-token': global_api_token,\r\n            'User-Agent': user_agent_string\r\n        }\r\n\r\n        url = (\r\n            f\"{api_host}/api/v0/corps/{global_corp_api_name}\"\r\n            f\"/activity?\"\r\n            f\"from={from_time}&until={until_time}\"\r\n        )\r\n        loop = True\r\n\r\n        counter = 1\r\n        helper.log_info(\"Pulling results from Corp Activity API\")\r\n        all_events = []\r\n        while loop:\r\n            helper.log_info(\"Processing page %s\" % counter)\r\n            start_page = timer()\r\n            response_result, response_code, response_error = \\\r\n                get_request_data(url, headers, helper)\r\n\r\n            pulled, request_details = check_response(\r\n                response_code,\r\n                response_error,\r\n                global_email=global_email,\r\n                global_corp_api_name=global_corp_api_name,\r\n                from_time=from_time,\r\n                until_time=until_time\r\n            )\r\n\r\n            if not pulled and request_details[\"msg\"] != \"rate-limit\":\r\n                helper.log_error(\"Failed to pull results\")\r\n                helper.log_error(request_details)\r\n                exit()\r\n            if not pulled and request_details[\"msg\"] == \"rate-limit\":\r\n                helper.log_error(\"Rate Limit hit\")\r\n                helper.log_error(\"Retrying in 10 seconds\")\r\n                time.sleep(10)\r\n                break\r\n            else:\r\n                response = response_result\r\n\r\n            number_requests_per_page = len(response['data'])\r\n            helper.log_info(\r\n                f\"Number of Requests for Page: {number_requests_per_page}\"\r\n            )\r\n            for request in response[\"data\"]:\r\n                data = json.dumps(request)\r\n                data = json.loads(data)\r\n                all_events.append(data)\r\n\r\n            if \"next\" in response and \"uri\" in response['next']:\r\n                next_url = response['next']['uri']\r\n                if next_url == '':\r\n                    helper.log_info(\"Finished Page %s\" % counter)\r\n                    counter += 1\r\n                    end_page = timer()\r\n                    page_time = end_page - start_page\r\n                    page_time_result = round(page_time, 2)\r\n                    helper.log_info(\r\n                        f\"Total Page Time: {page_time_result} seconds\"\r\n                    )\r\n                    loop = False\r\n                else:\r\n                    url = api_host + next_url\r\n                    helper.log_info(\"Finished Page %s\" % counter)\r\n                    counter += 1\r\n                    end_page = timer()\r\n                    page_time = end_page - start_page\r\n                    page_time_result = round(page_time, 2)\r\n                    helper.log_info(\r\n                        f\"Total Page Time: {page_time_result} seconds\"\r\n                    )\r\n            else:\r\n                loop = False\r\n\r\n        total_requests = len(all_events)\r\n        helper.log_info(\"Total Corp Activity Pulled: %s\" % total_requests)\r\n        write_start = timer()\r\n        for current_event in all_events:\r\n            # helper.log_debug(current_event)\r\n            # helper.log_info(f\"data={event_data}\")\r\n            current_event = json.dumps(current_event)\r\n            if key is None:\r\n                source_type = helper.get_sourcetype()\r\n                helper.log_info(\"Concurrent Mode\")\r\n                source_type_info = type(source_type)\r\n                active_index = helper.get_output_index()\r\n                index_info = type(active_index)\r\n                single_name_info = type(single_name)\r\n                current_event_info = type(current_event)\r\n                helper.log_info(f\"source_type: {source_type}\")\r\n                helper.log_info(f\"source_type_info: {source_type_info}\")\r\n                helper.log_info(f\"index: {active_index}\")\r\n                helper.log_info(f\"index_info: {index_info}\")\r\n                helper.log_info(f\"single_name: {single_name}\")\r\n                helper.log_info(f\"single_name_info: {single_name_info}\")\r\n                helper.log_info(f\"current_event: {current_event}\")\r\n                helper.log_info(f\"current_event_info: {current_event_info}\")\r\n                event = helper.new_event(\r\n                    source=single_name,\r\n                    index=helper.get_output_index(),\r\n                    sourcetype=source_type,\r\n                    data=current_event\r\n                )\r\n            else:\r\n                indexes = helper.get_output_index()\r\n                current_index = indexes[key]\r\n                types = helper.get_sourcetype()\r\n                source_type = types[key]\r\n                single_name = single_name[0]\r\n                helper.log_info(\"Sequential Mode\")\r\n                helper.log_info(f\"source_type: {source_type}\")\r\n                helper.log_info(f\"index: {current_index}\")\r\n                helper.log_info(f\"single_name: {single_name}\")\r\n                helper.log_info(f\"current_event: {current_event}\")\r\n                event = helper.new_event(\r\n                    source=single_name,\r\n                    index=current_index,\r\n                    sourcetype=source_type,\r\n                    data=current_event\r\n                )\r\n\r\n            try:\r\n                ew.write_event(event)\r\n            except Exception as e:\r\n                raise e\r\n        write_end = timer()\r\n        write_time = write_end - write_start\r\n        write_time_result = round(write_time, 2)\r\n        helper.log_info(\r\n            f\"Total Corp Activity Output Time: {write_time_result} seconds\"\r\n        )\r\n\r\n    # If multiple inputs configured it creates an array of values and the\r\n    # script only gets called once per Input configuration\r\n    time_deltas = helper.get_arg('interval')\r\n    helper.log_info(f\"interval: {time_deltas}\")\r\n    if type(time_deltas) is dict:\r\n        helper.log_info(\"run_type: Sequential\")\r\n        for active_input in time_deltas:\r\n            time_delta = time_deltas[active_input]\r\n            time_delta = int(time_delta)\r\n            helper.log_info(\"time_delta: %s\" % time_delta)\r\n            pull_events(\r\n                delta=time_delta,\r\n                key=active_input\r\n            )\r\n    else:\r\n        helper.log_info(\"Run Type: Concurrent\")\r\n        helper.log_info(\"time_delta: %s\" % time_deltas)\r\n        pull_events(\r\n            delta=int(time_deltas)\r\n        )\r\n    helper.log_info(\"Finished Pulling Corp Activity\")\r\n    end = timer()\r\n    total_time = end - start\r\n    time_result = round(total_time, 2)\r\n    helper.log_info(f\"Total Script Time: {time_result} seconds\")\r\n", "customized_options": [{"name": "place_holder", "value": ""}], "uuid": "07b37d1943e942cf831c8ee85ffcb4a2", "sample_count": "1"}, {"index": "default", "sourcetype": "sigsci-requests", "interval": "300", "use_external_validation": true, "streaming_mode_xml": true, "name": "SigsciRequests", "title": "SigsciRequests", "description": "", "type": "customized", "parameters": [{"name": "site_api_name", "label": "Site API Name", "help_string": "This is the API Name of the site to pull date from. This should not be a URL.", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "splunk-demo-server"}], "data_inputs_options": [{"type": "customized_var", "name": "site_api_name", "title": "Site API Name", "description": "This is the API Name of the site to pull date from. This should not be a URL.", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}], "customized_options": [{"name": "site_api_name", "value": "splunk-demo-server"}], "code": "# encoding = utf-8\r\n\r\nimport time\r\nfrom datetime import datetime, timedelta\r\nfrom timeit import default_timer as timer\r\nimport requests\r\nimport calendar\r\nimport json\r\nfrom sigsci_helper import check_response, get_request_data\r\n\r\n'''\r\n    IMPORTANT\r\n    Edit only the validate_input and collect_events functions.\r\n    Do not edit any other part in this file.\r\n    This file is generated only once when creating the modular input.\r\n'''\r\n\r\n\r\n# def use_single_instance_mode():\r\n#     return True\r\n\r\n\r\ndef validate_input(helper, definition):\r\n    # This example accesses the modular input variable\r\n    site_name = definition.parameters.get('site_api_name', None)\r\n    if site_name is None or site_name == \"\":\r\n        msg = \"The site_name can not be empty\"\r\n        raise ValueError(\r\n            \"InvalidSiteName\",\r\n            msg\r\n        )\r\n    elif \"http\" in site_name:\r\n        msg = (\r\n            \"The site name is not the full URL it should be the \",\r\n            \"API Name of the site like 'my_example_site'\"\r\n        )\r\n        raise ValueError(\r\n            \"InvalidSiteName\",\r\n            msg\r\n        )\r\n    elif \" \" in site_name:\r\n        msg = (\r\n            \"The site name should be the API Name of the site like \",\r\n            \"not the Display Name. Example would be 'my_site_name' instead of \",\r\n            \"My Site Name\"\r\n        )\r\n        raise ValueError(\r\n            \"InvalidSiteName\",\r\n            msg\r\n        )\r\n    pass\r\n\r\n\r\ndef collect_events(helper, ew):\r\n    start = timer()\r\n    # loglevel = helper.get_log_level()\r\n    # Proxy setting configuration\r\n    # proxy_settings = helper.get_proxy()\r\n    global_email = helper.get_global_setting(\"email\")\r\n    global_api_token = helper.get_global_setting(\"api_token\")\r\n    global_corp_api_name = helper.get_global_setting(\"corp_api_name\")\r\n    api_host = 'https://dashboard.signalsciences.net'\r\n    helper.log_info(\"email: %s\" % global_email)\r\n    helper.log_info(\"corp: %s\" % global_corp_api_name)\r\n    python_requests_version = requests.__version__\r\n    user_agent_version = \"1.0.26\"\r\n    user_agent_string = (\r\n        f\"TA-sigsci-waf/{user_agent_version} \"\r\n        f\"(PythonRequests {python_requests_version})\"\r\n    )\r\n\r\n    def pull_requests(current_site, delta, key=None):\r\n        site_name = current_site\r\n        until_time = datetime.utcnow() - timedelta(minutes=5)\r\n        until_time = until_time.replace(second=0, microsecond=0)\r\n        from_time = until_time - timedelta(seconds=delta)\r\n        until_time = calendar.timegm(until_time.utctimetuple())\r\n        from_time = calendar.timegm(from_time.utctimetuple())\r\n        from_time_friendly = datetime.fromtimestamp(from_time)\r\n        until_time_friendly = datetime.fromtimestamp(until_time)\r\n        helper.log_info(\"SiteName: %s\" % site_name)\r\n\r\n        helper.log_info(f\"Start Period: {from_time_friendly}\")\r\n        helper.log_info(f\"End Period: {until_time_friendly}\")\r\n\r\n\r\n        input_name = helper.get_input_stanza_names()\r\n        single_name = \"\"\r\n\r\n        if type(input_name) is dict and input_name > 1:\r\n            helper.log_info(\"Multi instance mode\")\r\n            for current_name in input_name:\r\n                single_name = current_name\r\n        else:\r\n            helper.log_info(\"Single instance mode\")\r\n            helper.log_info(\"Inputs: %s\" % input_name)\r\n            helper.log_info(\"Inputs Num: %s\" % len(input_name))\r\n            single_name = input_name\r\n            helper.log_info(f\"single_name: {single_name}\")\r\n\r\n        # Loop across all the data and output it in one big JSON object\r\n        headers = {\r\n            'Content-type': 'application/json',\r\n            'x-api-user': global_email,\r\n            'x-api-token': global_api_token,\r\n            'User-Agent': user_agent_string\r\n        }\r\n\r\n        url = (\r\n            f\"{api_host}/api/v0/corps/{global_corp_api_name}\"\r\n            f\"/sites/{site_name}/feed/requests?\"\r\n            f\"from={from_time}&until={until_time}\"\r\n        )\r\n        loop = True\r\n\r\n        counter = 1\r\n        helper.log_info(\"Pulling requests from requests API\")\r\n        all_requests = []\r\n        while loop:\r\n            helper.log_info(\"Processing page %s\" % counter)\r\n            start_page = timer()\r\n            response_result, response_code, response_error = \\\r\n                get_request_data(url, headers, helper)\r\n\r\n            pulled, request_details = check_response(\r\n                response_code,\r\n                response_error,\r\n                global_email=global_email,\r\n                global_corp_api_name=global_corp_api_name,\r\n                current_site=site_name,\r\n                from_time=from_time,\r\n                until_time=until_time\r\n            )\r\n\r\n            if not pulled and request_details[\"msg\"] != \"rate-limit\":\r\n                helper.log_error(\"Failed to pull results\")\r\n                helper.log_error(request_details)\r\n                exit()\r\n            if not pulled and request_details[\"msg\"] == \"rate-limit\":\r\n                helper.log_error(\"Rate Limit hit\")\r\n                helper.log_error(\"Retrying in 10 seconds\")\r\n                time.sleep(10)\r\n                break\r\n            else:\r\n                response = response_result\r\n\r\n            number_requests_per_page = len(response['data'])\r\n            helper.log_info(\r\n                f\"Number of Requests for Page: {number_requests_per_page}\"\r\n            )\r\n\r\n            for request in response['data']:\r\n                data = json.dumps(request)\r\n                data = json.loads(data)\r\n                headers_to_fix = {\r\n                    'headersOut': data['headersOut'],\r\n                    'headersIn': data['headersIn']\r\n                }\r\n\r\n                new_format_out = {}\r\n\r\n                if not (headers_to_fix['headersOut'] is None):\r\n                    for out in headers_to_fix['headersOut']:\r\n                        new_format_out[out[0]] = out[1]\r\n\r\n                    data['headersOut'] = new_format_out\r\n\r\n                new_format_in = {}\r\n\r\n                if not (headers_to_fix['headersIn'] is None):\r\n                    for header_in in headers_to_fix['headersIn']:\r\n                        headers_to_fix[header_in[0]] = header_in[1]\r\n\r\n                    data['headersIn'] = headers_to_fix\r\n\r\n                data = json.dumps(data)\r\n\r\n                # helper.log_debug(\"%s\" % data)\r\n                all_requests.append(data)\r\n\r\n            if \"next\" in response and \"uri\" in response['next']:\r\n                next_url = response['next']['uri']\r\n                if next_url == '':\r\n                    helper.log_info(\"Finished Page %s\" % counter)\r\n                    counter += 1\r\n                    end_page = timer()\r\n                    page_time = end_page - start_page\r\n                    page_time_result = round(page_time, 2)\r\n                    helper.log_info(\r\n                        f\"Total Page Time: {page_time_result} seconds\"\r\n                    )\r\n                    loop = False\r\n                else:\r\n                    url = api_host + next_url\r\n                    helper.log_info(\"Finished Page %s\" % counter)\r\n                    counter += 1\r\n                    end_page = timer()\r\n                    page_time = end_page - start_page\r\n                    page_time_result = round(page_time, 2)\r\n                    helper.log_info(\r\n                        f\"Total Page Time: {page_time_result} seconds\"\r\n                    )\r\n            else:\r\n                loop = False\r\n\r\n        total_requests = len(all_requests)\r\n        helper.log_info(\"Total Requests Pulled: %s\" % total_requests)\r\n        write_start = timer()\r\n        for current_event in all_requests:\r\n            # helper.log_debug(current_event)\r\n            # helper.log_info(f\"data={event_data}\")\r\n            if key is None:\r\n                # helper.log_info(\"input_type=single\")\r\n                source_index = helper.get_output_index()\r\n                source_type = helper.get_sourcetype()\r\n                # helper.log_info(f\"source={single_name}\")\r\n                # helper.log_info(f\"index={source_index}\")\r\n                # helper.log_info(f\"source_type={source_type}\")\r\n                event = helper.new_event(\r\n                    source=single_name,\r\n                    index=helper.get_output_index(),\r\n                    sourcetype=source_type,\r\n                    data=current_event\r\n                )\r\n            else:\r\n                # helper.log_info(\"input_type=multi\")\r\n                indexes = helper.get_output_index()\r\n                current_index = indexes[key]\r\n                types = helper.get_sourcetype()\r\n                source_type = types[key]\r\n                single_name = single_name[0]\r\n                event = helper.new_event(\r\n                    source=single_name,\r\n                    index=current_index,\r\n                    sourcetype=source_type,\r\n                    data=current_event\r\n                )\r\n\r\n            try:\r\n                ew.write_event(event)\r\n            except Exception as e:\r\n                helper.log_error(event)\r\n                raise e\r\n        write_end = timer()\r\n        write_time = write_end - write_start\r\n        write_time_result = round(write_time, 2)\r\n        helper.log_info(\"Total Event Output Time: %s seconds\"\r\n                        % write_time_result)\r\n\r\n    # If multiple inputs configured it creates an array of values and the\r\n    # script only gets called once per Input configuration\r\n    all_sites = helper.get_arg('site_api_name')\r\n    time_deltas = helper.get_arg('interval')\r\n    helper.log_info(f\"interval: {time_deltas}\")\r\n    if type(all_sites) is dict:\r\n        helper.log_info(\"run_type: Sequential\")\r\n        for active_input in all_sites:\r\n            site = all_sites[active_input]\r\n            time_delta = int(time_deltas[active_input])\r\n            helper.log_info(\"site: %s\" % site)\r\n            pull_requests(\r\n                key=active_input,\r\n                current_site=site,\r\n                delta=time_delta\r\n            )\r\n            helper.log_info(\"Finished Pulling Requests for %s\" % site)\r\n    else:\r\n        helper.log_info(\"Run Type: Concurrent\")\r\n        site = helper.get_arg('site_api_name')\r\n        helper.log_info(\"site: %s\" % site)\r\n        pull_requests(\r\n            current_site=site,\r\n            delta=int(time_deltas)\r\n        )\r\n        helper.log_info(\"Finished Pulling Requests for %s\" % site)\r\n    end = timer()\r\n    total_time = end - start\r\n    time_result = round(total_time, 2)\r\n    helper.log_info(\"Total Script Time: %s seconds\" % time_result)", "uuid": "aaaeb391da9043e1819408033d9db708", "sample_count": "18460"}]}, "field_extraction_builder": {"sigsci-requests": {"is_parsed": true, "data_format": "json"}, "sigsci-event": {"is_parsed": true, "data_format": "json"}, "sigsci-activity": {"is_parsed": true, "data_format": "json"}}, "global_settings_builder": {"global_settings": {"proxy_settings": {"proxy_type": "http"}, "log_settings": {"log_level": "DEBUG"}, "customized_settings": [{"required": true, "name": "email", "label": "E-mail", "default_value": "", "placeholder": "example@example.com", "help_string": "This it the e-mail username of the user who has the correct permissions for the app to pull the data.", "type": "text", "format_type": "text", "value": "dacoburn@dactbc.com"}, {"required": true, "name": "corp_api_name", "label": "Corp", "default_value": "", "placeholder": "", "help_string": "This is the API name of your corp.", "type": "text", "format_type": "text", "value": "dactbc"}, {"required": true, "name": "api_token", "label": "API Token", "placeholder": "", "default_value": "", "help_string": "This is the API Token of the user who has the correct permissions. The API Token is tied to the username.", "type": "password", "format_type": "password", "value": ""}]}}, "sourcetype_builder": {"sigsci-requests": {"metadata": {"event_count": 0, "data_input_name": "SigsciRequests", "extractions_count": 0, "cims_count": 0}}, "sigsci-event": {"metadata": {"event_count": 0, "data_input_name": "SigsciEvent", "extractions_count": 0, "cims_count": 0}}, "sigsci-activity": {"metadata": {"event_count": 0, "data_input_name": "SigsciActivity", "extractions_count": 0, "cims_count": 0}}}, "validation": {"validators": ["best_practice_validation", "data_model_mapping_validation", "field_extract_validation", "app_cert_validation"], "status": "job_finished", "validation_id": "v_1683517650_27", "progress": 1.0}}